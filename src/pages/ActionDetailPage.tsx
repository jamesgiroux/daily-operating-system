import { useState, useEffect, useCallback, useRef } from "react";
import { useParams, Link } from "@tanstack/react-router";
import { invoke } from "@tauri-apps/api/core";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Skeleton } from "@/components/ui/skeleton";
import { ScrollArea } from "@/components/ui/scroll-area";
import { PriorityPicker } from "@/components/ui/priority-picker";
import { EntityPicker } from "@/components/ui/entity-picker";
import { PageError } from "@/components/PageState";
import { cn } from "@/lib/utils";
import {
  ArrowLeft,
  Calendar,
  CheckCircle2,
  Circle,
  Building2,
  MessageSquare,
  Clock,
  Pencil,
  Tag,
} from "lucide-react";
import type { ActionDetail } from "@/types";

export default function ActionDetailPage() {
  const { actionId } = useParams({ strict: false }) as {
    actionId?: string;
  };
  const [detail, setDetail] = useState<ActionDetail | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [toggling, setToggling] = useState(false);

  const load = useCallback(async () => {
    if (!actionId) return;
    try {
      setLoading(true);
      setError(null);
      const result = await invoke<ActionDetail>("get_action_detail", {
        actionId,
      });
      setDetail(result);
    } catch (e) {
      setError(String(e));
    } finally {
      setLoading(false);
    }
  }, [actionId]);

  useEffect(() => {
    load();
  }, [load]);

  async function toggleStatus() {
    if (!detail) return;
    setToggling(true);
    try {
      if (detail.status === "completed") {
        await invoke("reopen_action", { id: detail.id });
      } else {
        await invoke("complete_action", { id: detail.id });
      }
      await load();
    } finally {
      setToggling(false);
    }
  }

  async function saveField(updates: Record<string, unknown>) {
    if (!detail) return;
    await invoke("update_action", {
      request: { id: detail.id, ...updates },
    });
    await load();
  }

  if (loading) {
    return (
      <main className="flex-1 overflow-hidden p-6">
        <Skeleton className="mb-4 h-8 w-32" />
        <Skeleton className="mb-2 h-10 w-96" />
        <Skeleton className="mt-6 h-48 w-full" />
      </main>
    );
  }

  if (error || !detail) {
    return (
      <main className="flex-1 overflow-hidden">
        <PageError message={error ?? "Action not found"} onRetry={load} />
      </main>
    );
  }

  const isCompleted = detail.status === "completed";
  const hasSource = detail.sourceId && detail.sourceMeetingTitle;
  const isAutoGenerated = detail.sourceType && detail.sourceType !== "manual";

  return (
    <main className="flex-1 overflow-hidden">
      <ScrollArea className="h-full">
        <div className="mx-auto max-w-2xl space-y-6 p-6">
          {/* Back link */}
          <button
            onClick={() => window.history.back()}
            className="inline-flex items-center gap-1 text-sm text-muted-foreground transition-colors hover:text-foreground"
          >
            <ArrowLeft className="size-4" />
            Back
          </button>

          {/* Header — editable title */}
          <div className="space-y-3">
            <div className="flex items-start gap-3">
              <button
                onClick={toggleStatus}
                disabled={toggling}
                className="mt-1 shrink-0 transition-colors hover:text-primary disabled:opacity-50"
                title={isCompleted ? "Reopen action" : "Complete action"}
              >
                {isCompleted ? (
                  <CheckCircle2 className="size-5 text-primary" />
                ) : (
                  <Circle className="size-5 text-muted-foreground" />
                )}
              </button>
              <EditableText
                value={detail.title}
                onSave={(title) => saveField({ title })}
                className={cn(
                  "text-xl font-semibold tracking-tight",
                  isCompleted && "line-through opacity-60"
                )}
              />
            </div>

            {isAutoGenerated && (
              <p className="pl-8 text-xs text-muted-foreground/60 italic">
                Edited manually — may be overwritten by next briefing
              </p>
            )}

            <div className="flex flex-wrap items-center gap-2">
              <PriorityPicker
                value={detail.priority}
                onChange={(p) => saveField({ priority: p })}
              />
              <Badge
                variant="outline"
                className={cn(
                  "text-xs",
                  isCompleted
                    ? "border-primary/50 text-primary"
                    : "text-muted-foreground"
                )}
              >
                {isCompleted ? "Completed" : "Open"}
              </Badge>
              {detail.waitingOn && (
                <Badge variant="outline" className="text-xs">
                  Waiting on: {detail.waitingOn}
                </Badge>
              )}
            </div>
          </div>

          {/* Context — editable */}
          <Card>
            <CardHeader className="pb-3">
              <CardTitle className="flex items-center gap-2 text-sm font-medium">
                <MessageSquare className="size-4 text-muted-foreground" />
                Context
              </CardTitle>
            </CardHeader>
            <CardContent>
              <EditableTextarea
                value={detail.context ?? ""}
                onSave={(context) =>
                  context
                    ? saveField({ context })
                    : saveField({ clearContext: true })
                }
                placeholder="Add context..."
              />
              {isAutoGenerated && detail.context && (
                <p className="mt-1 text-xs text-muted-foreground/60 italic">
                  May be overwritten by next briefing
                </p>
              )}
            </CardContent>
          </Card>

          {/* Details */}
          <Card>
            <CardHeader className="pb-3">
              <CardTitle className="text-sm font-medium">Details</CardTitle>
            </CardHeader>
            <CardContent className="space-y-3">
              {/* Source meeting */}
              {hasSource && (
                <div className="flex items-start gap-3 text-sm">
                  <Calendar className="mt-0.5 size-4 shrink-0 text-muted-foreground" />
                  <div>
                    <span className="text-muted-foreground">
                      From meeting:{" "}
                    </span>
                    <Link
                      to="/meeting/$meetingId"
                      params={{ meetingId: detail.sourceId! }}
                      className="text-primary transition-colors hover:underline"
                    >
                      {detail.sourceMeetingTitle}
                    </Link>
                  </div>
                </div>
              )}

              {/* Source label — editable */}
              {!hasSource && (
                <div className="flex items-start gap-3 text-sm">
                  <Tag className="mt-0.5 size-4 shrink-0 text-muted-foreground" />
                  <div className="flex-1">
                    <span className="text-muted-foreground">Source: </span>
                    <EditableInline
                      value={detail.sourceLabel ?? ""}
                      onSave={(v) =>
                        v
                          ? saveField({ sourceLabel: v })
                          : saveField({ clearSourceLabel: true })
                      }
                      placeholder="Add source"
                    />
                  </div>
                </div>
              )}

              {/* Account — editable via EntityPicker */}
              <div className="flex items-start gap-3 text-sm">
                <Building2 className="mt-0.5 size-4 shrink-0 text-muted-foreground" />
                <div className="flex-1">
                  <span className="text-muted-foreground">Account: </span>
                  {detail.accountId && detail.accountName ? (
                    <span className="inline-flex items-center gap-1">
                      <Link
                        to="/accounts/$accountId"
                        params={{ accountId: detail.accountId }}
                        className="text-primary transition-colors hover:underline"
                      >
                        {detail.accountName}
                      </Link>
                      <button
                        onClick={() => saveField({ clearAccount: true })}
                        className="text-muted-foreground hover:text-foreground"
                        title="Remove account"
                      >
                        ×
                      </button>
                    </span>
                  ) : (
                    <EntityPicker
                      value={null}
                      onChange={(id) => {
                        if (id) saveField({ accountId: id });
                      }}
                      entityType="account"
                      placeholder="Link account"
                    />
                  )}
                </div>
              </div>

              {/* Due date — editable */}
              <div className="flex items-start gap-3 text-sm">
                <Clock className="mt-0.5 size-4 shrink-0 text-muted-foreground" />
                <div className="flex-1">
                  <span className="text-muted-foreground">Due: </span>
                  <EditableDate
                    value={detail.dueDate ?? ""}
                    onSave={(v) =>
                      v
                        ? saveField({ dueDate: v })
                        : saveField({ clearDueDate: true })
                    }
                  />
                </div>
              </div>

              {/* Created (read-only) */}
              <div className="flex items-start gap-3 text-sm">
                <Clock className="mt-0.5 size-4 shrink-0 text-muted-foreground" />
                <div>
                  <span className="text-muted-foreground">Created: </span>
                  <span>{formatDate(detail.createdAt)}</span>
                </div>
              </div>

              {/* Completed (read-only) */}
              {detail.completedAt && (
                <div className="flex items-start gap-3 text-sm">
                  <CheckCircle2 className="mt-0.5 size-4 shrink-0 text-primary" />
                  <div>
                    <span className="text-muted-foreground">Completed: </span>
                    <span>{formatDate(detail.completedAt)}</span>
                  </div>
                </div>
              )}
            </CardContent>
          </Card>

          {/* Toggle action */}
          <div className="flex justify-end">
            <Button
              variant="outline"
              size="sm"
              onClick={toggleStatus}
              disabled={toggling}
            >
              {isCompleted ? "Reopen" : "Mark Complete"}
            </Button>
          </div>
        </div>
      </ScrollArea>
    </main>
  );
}

// =============================================================================
// Inline Editable Components
// =============================================================================

/** Click-to-edit single-line text (for title, source label). */
function EditableText({
  value,
  onSave,
  className,
  placeholder,
}: {
  value: string;
  onSave: (v: string) => void;
  className?: string;
  placeholder?: string;
}) {
  const [editing, setEditing] = useState(false);
  const [draft, setDraft] = useState(value);
  const inputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    setDraft(value);
  }, [value]);

  useEffect(() => {
    if (editing) inputRef.current?.select();
  }, [editing]);

  function commit() {
    setEditing(false);
    if (draft.trim() && draft.trim() !== value) {
      onSave(draft.trim());
    } else {
      setDraft(value);
    }
  }

  if (editing) {
    return (
      <input
        ref={inputRef}
        type="text"
        value={draft}
        onChange={(e) => setDraft(e.target.value)}
        onBlur={commit}
        onKeyDown={(e) => {
          if (e.key === "Enter") commit();
          if (e.key === "Escape") {
            setDraft(value);
            setEditing(false);
          }
        }}
        className={cn(
          "w-full rounded border-b bg-transparent outline-none focus:border-primary",
          className
        )}
      />
    );
  }

  return (
    <span
      onClick={() => setEditing(true)}
      className={cn(
        "group cursor-pointer",
        className
      )}
    >
      {value || (
        <span className="text-muted-foreground/60">{placeholder ?? "Click to edit"}</span>
      )}
      <Pencil className="ml-1 inline size-3 text-muted-foreground/0 group-hover:text-muted-foreground/50" />
    </span>
  );
}

/** Click-to-edit short inline text. */
function EditableInline({
  value,
  onSave,
  placeholder,
}: {
  value: string;
  onSave: (v: string) => void;
  placeholder?: string;
}) {
  const [editing, setEditing] = useState(false);
  const [draft, setDraft] = useState(value);
  const inputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    setDraft(value);
  }, [value]);

  useEffect(() => {
    if (editing) inputRef.current?.focus();
  }, [editing]);

  function commit() {
    setEditing(false);
    if (draft.trim() !== value) {
      onSave(draft.trim());
    }
  }

  if (editing) {
    return (
      <input
        ref={inputRef}
        type="text"
        value={draft}
        onChange={(e) => setDraft(e.target.value)}
        onBlur={commit}
        onKeyDown={(e) => {
          if (e.key === "Enter") commit();
          if (e.key === "Escape") {
            setDraft(value);
            setEditing(false);
          }
        }}
        placeholder={placeholder}
        className="rounded border-b bg-transparent text-sm outline-none focus:border-primary"
      />
    );
  }

  return (
    <span
      onClick={() => setEditing(true)}
      className="group cursor-pointer"
    >
      {value ? (
        <span>{value}</span>
      ) : (
        <span className="text-muted-foreground/60">{placeholder ?? "Add"}</span>
      )}
      <Pencil className="ml-1 inline size-3 text-muted-foreground/0 group-hover:text-muted-foreground/50" />
    </span>
  );
}

/** Click-to-edit multiline text. */
function EditableTextarea({
  value,
  onSave,
  placeholder,
}: {
  value: string;
  onSave: (v: string) => void;
  placeholder?: string;
}) {
  const [editing, setEditing] = useState(false);
  const [draft, setDraft] = useState(value);
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  useEffect(() => {
    setDraft(value);
  }, [value]);

  useEffect(() => {
    if (editing) textareaRef.current?.focus();
  }, [editing]);

  function commit() {
    setEditing(false);
    if (draft.trim() !== value) {
      onSave(draft.trim());
    }
  }

  if (editing) {
    return (
      <textarea
        ref={textareaRef}
        value={draft}
        onChange={(e) => setDraft(e.target.value)}
        onBlur={commit}
        onKeyDown={(e) => {
          if (e.key === "Escape") {
            setDraft(value);
            setEditing(false);
          }
        }}
        placeholder={placeholder}
        rows={3}
        className="w-full resize-none rounded border bg-transparent px-2 py-1 text-sm leading-relaxed outline-none focus:border-primary"
      />
    );
  }

  return (
    <div
      onClick={() => setEditing(true)}
      className="group cursor-pointer"
    >
      {value ? (
        <p className="text-sm leading-relaxed whitespace-pre-line">{value}</p>
      ) : (
        <p className="text-sm text-muted-foreground/60">{placeholder ?? "Click to add..."}</p>
      )}
      <Pencil className="mt-1 inline size-3 text-muted-foreground/0 group-hover:text-muted-foreground/50" />
    </div>
  );
}

/** Click-to-edit date field. */
function EditableDate({
  value,
  onSave,
}: {
  value: string;
  onSave: (v: string) => void;
}) {
  const [editing, setEditing] = useState(false);
  const inputRef = useRef<HTMLInputElement>(null);

  // Normalize value to YYYY-MM-DD for input
  const dateValue = value ? value.split("T")[0] : "";

  useEffect(() => {
    if (editing) inputRef.current?.focus();
  }, [editing]);

  if (editing) {
    return (
      <span className="inline-flex items-center gap-1">
        <input
          ref={inputRef}
          type="date"
          defaultValue={dateValue}
          onBlur={(e) => {
            setEditing(false);
            const v = e.target.value;
            if (v !== dateValue) onSave(v);
          }}
          onChange={(e) => {
            const v = e.target.value;
            if (v !== dateValue) {
              onSave(v);
              setEditing(false);
            }
          }}
          className="rounded border bg-transparent px-1 text-sm outline-none focus:border-primary"
        />
        {dateValue && (
          <button
            onClick={() => {
              onSave("");
              setEditing(false);
            }}
            className="text-xs text-muted-foreground hover:text-foreground"
          >
            Clear
          </button>
        )}
      </span>
    );
  }

  return (
    <span
      onClick={() => setEditing(true)}
      className="group cursor-pointer"
    >
      {dateValue ? (
        <span>{formatDate(dateValue)}</span>
      ) : (
        <span className="text-muted-foreground/60">Add due date</span>
      )}
      <Pencil className="ml-1 inline size-3 text-muted-foreground/0 group-hover:text-muted-foreground/50" />
    </span>
  );
}

function formatDate(dateStr: string): string {
  try {
    const date = new Date(dateStr);
    return date.toLocaleDateString(undefined, {
      weekday: "short",
      month: "short",
      day: "numeric",
      year: "numeric",
    });
  } catch {
    return dateStr.split("T")[0] ?? dateStr;
  }
}
