name: Release

on:
  push:
    tags:
      - "v*"

permissions:
  contents: write

jobs:
  build-macos:
    runs-on: macos-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Verify version matches tag
        run: |
          TAG_VERSION="${GITHUB_REF_NAME#v}"
          CONF_VERSION=$(grep '"version"' src-tauri/tauri.conf.json | head -1 | sed 's/.*: "\(.*\)".*/\1/')
          if [ "$TAG_VERSION" != "$CONF_VERSION" ]; then
            echo "ERROR: Tag version ($TAG_VERSION) does not match tauri.conf.json version ($CONF_VERSION)"
            exit 1
          fi
          echo "Version verified: $TAG_VERSION"

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "pnpm"

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: aarch64-apple-darwin

      - name: Cache Rust dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin
            ~/.cargo/registry
            ~/.cargo/git
            src-tauri/target
          key: macos-cargo-${{ hashFiles('src-tauri/Cargo.lock') }}
          restore-keys: |
            macos-cargo-

      - name: Import Apple certificate
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          # Decode certificate
          echo "$APPLE_CERTIFICATE" | base64 --decode > certificate.p12

          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" build.keychain

          # Prevent keychain auto-lock during long Rust compilations
          security set-keychain-settings -t 3600 -u build.keychain

          # Add build.keychain to search list (codesign searches this, not just default)
          security list-keychains -d user -s build.keychain $(security list-keychains -d user | sed -e 's/"//g')

          # Import certificate
          security import certificate.p12 -k build.keychain \
            -P "$APPLE_CERTIFICATE_PASSWORD" \
            -T /usr/bin/codesign \
            -T /usr/bin/security \
            -T /usr/bin/productbuild \
            -T /usr/bin/productsign

          # Allow codesign to access keychain without UI prompt
          security set-key-partition-list -S apple-tool:,apple:,codesign: \
            -s -k "$KEYCHAIN_PASSWORD" build.keychain

          # Verify keychain is searchable
          echo "Keychain search list:"
          security list-keychains -d user

          # Find signing identity
          IDENTITY=$(security find-identity -v -p codesigning build.keychain | grep "Developer ID Application" | head -1 | awk -F'"' '{print $2}')
          if [ -z "$IDENTITY" ]; then
            echo "ERROR: No Developer ID Application identity found"
            security find-identity -v -p codesigning build.keychain
            exit 1
          fi
          echo "APPLE_SIGNING_IDENTITY=$IDENTITY" >> "$GITHUB_ENV"
          echo "Found signing identity: $IDENTITY"

          # Clean up
          rm certificate.p12

      # NOTE: Notarization disabled for now (API key auth hangs during submission).
      # App is code-signed but not notarized. Users need: xattr -cr /Applications/DailyOS.app
      # TODO: Re-enable notarization once Apple API key submission is debugged.
      # Secrets ready: APPLE_API_KEY, APPLE_API_ISSUER, APPLE_API_KEY_PATH_BASE64

      - name: Install frontend dependencies
        run: pnpm install

      - name: Verify Google OAuth build secret
        env:
          DAILYOS_GOOGLE_SECRET: ${{ secrets.DAILYOS_GOOGLE_SECRET }}
        run: |
          if [ -z "$DAILYOS_GOOGLE_SECRET" ]; then
            echo "Missing DAILYOS_GOOGLE_SECRET. Set repo secret before building release artifacts."
            exit 1
          fi

      - name: Build Tauri app (macOS arm64, signed)
        timeout-minutes: 30
        env:
          DAILYOS_GOOGLE_SECRET: ${{ secrets.DAILYOS_GOOGLE_SECRET }}
          APPLE_SIGNING_IDENTITY: ${{ env.APPLE_SIGNING_IDENTITY }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: pnpm tauri build --target aarch64-apple-darwin

      - name: Collect artifacts
        id: artifacts
        run: |
          BUNDLE_DIR="src-tauri/target/aarch64-apple-darwin/release/bundle"

          # DMG for fresh installs
          DMG_PATH=$(ls "$BUNDLE_DIR"/dmg/*.dmg)
          DMG_NAME=$(basename "$DMG_PATH")
          echo "dmg_path=$DMG_PATH" >> "$GITHUB_OUTPUT"
          echo "dmg_name=$DMG_NAME" >> "$GITHUB_OUTPUT"

          # Updater artifacts (.tar.gz and .tar.gz.sig)
          TARBALL_PATH=$(ls "$BUNDLE_DIR"/macos/*.tar.gz | grep -v '.sig$')
          TARBALL_NAME=$(basename "$TARBALL_PATH")
          SIG_PATH="${TARBALL_PATH}.sig"
          echo "tarball_path=$TARBALL_PATH" >> "$GITHUB_OUTPUT"
          echo "tarball_name=$TARBALL_NAME" >> "$GITHUB_OUTPUT"
          echo "sig_path=$SIG_PATH" >> "$GITHUB_OUTPUT"

          # Signature is multiline (Minisign format) — use heredoc for GITHUB_OUTPUT
          echo "sig_content<<SIG_EOF" >> "$GITHUB_OUTPUT"
          cat "$SIG_PATH" >> "$GITHUB_OUTPUT"
          echo "SIG_EOF" >> "$GITHUB_OUTPUT"

      - name: Generate latest.json
        run: |
          VERSION="${GITHUB_REF_NAME#v}"
          PUB_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          TARBALL_NAME="${{ steps.artifacts.outputs.tarball_name }}"
          REPO_URL="https://github.com/${{ github.repository }}"
          SIG_PATH="${{ steps.artifacts.outputs.sig_path }}"

          # Signature is multiline — use jq to JSON-escape it
          SIG_JSON=$(cat "$SIG_PATH" | jq -Rs .)

          # Build latest.json with jq for safe JSON construction
          jq -n \
            --arg version "$VERSION" \
            --arg notes "DailyOS v$VERSION" \
            --arg pub_date "$PUB_DATE" \
            --arg url "$REPO_URL/releases/download/${{ github.ref_name }}/$TARBALL_NAME" \
            --arg sig "$(cat "$SIG_PATH")" \
            '{
              version: $version,
              notes: $notes,
              pub_date: $pub_date,
              platforms: {
                "darwin-aarch64": {
                  signature: $sig,
                  url: $url
                }
              }
            }' > latest.json

          echo "Generated latest.json:"
          cat latest.json

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          name: DailyOS ${{ github.ref_name }}
          body: |
            ## Installation

            **New users:**
            1. Download `${{ steps.artifacts.outputs.dmg_name }}`
            2. Drag DailyOS to Applications
            3. Open DailyOS

            **Existing users:** DailyOS will update automatically. Check Settings for details.
          files: |
            ${{ steps.artifacts.outputs.dmg_path }}
            ${{ steps.artifacts.outputs.tarball_path }}
            ${{ steps.artifacts.outputs.sig_path }}
            latest.json
          draft: false
          prerelease: false

      - name: Cleanup keychain
        if: always()
        run: |
          security delete-keychain build.keychain 2>/dev/null || true
