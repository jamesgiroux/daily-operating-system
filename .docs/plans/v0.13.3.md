# v0.13.3 Version Brief

**Thesis:** Parent accounts are not folders — they're portfolio surfaces. A user managing 10 Salesforce BUs under one parent company needs a surface that shows them the whole picture: which BUs are healthy, which need attention, what patterns are emerging across the portfolio that no individual BU page can reveal. This version makes the parent account entity into that surface. It also adds partner as a first-class entity type (agencies, SIs, channel partners have different intelligence shapes than customers), regroups the AccountsPage to match, and wires bidirectional signal propagation so BU signals accumulate at the parent and significant parent-level events cascade down to BUs — without the user having to specify which children are affected. (ADR-0087)

**Status:** Planning.

---

## Scope

### In

| ID | Title | Area |
|----|-------|------|
| I382 | Partner entity type — `partner` account type, badge, prompt shape | Backend / Entity |
| I383 | AccountsPage three-group layout — Your Book / Your Team / Your Partners | Frontend / UX |
| I384 | Parent account portfolio intelligence — two-layer intelligence.json | Backend / Intelligence |
| I385 | Bidirectional entity hierarchy signal propagation — upward accumulation, downward fan-out | Backend / Signals |
| I386 | Parent account detail page — portfolio surface (hotspots, cross-BU patterns, portfolio narrative) | Frontend / UX |

### Explicitly out

- Multi-entity signal extraction from parent-level meetings (I387) — content-level entity resolution in the transcript processor; deferred per ADR-0087. User behavior is to tag at the parent level; bidirectional propagation (I385) provides sufficient coverage for now.
- Changes to leaf-node (child) account intelligence shape or detail pages
- Changes to person or project entity types
- New integrations
- Salesforce or CRM sync (separate concern; entity hierarchy can be populated manually for now)

---

## Acceptance Criteria

Each criterion must be verified with real data in the running app after a full `pnpm dev` restart. Compilation is not acceptance. Types aligning is not acceptance. A criterion is met when the described behavior is observable with real entities in the running app.

---

### I382 — Partner entity type

1. `partner` is a valid `account_type` in the DB enum and Rust type system. Creating an account with type `partner` via the UI or directly in the DB succeeds without error.
2. Partner accounts render with a distinct visual badge on account cards, account detail pages, and anywhere account type is displayed (meeting attendee context, entity chips). The badge is visually differentiated from both `customer` and `internal`.
3. The AI enrichment prompt for partner entities uses a partner-appropriate shape — alignment health, joint deliverables, communication cadence, escalation risk — not the customer health/spend/renewal shape and not the internal coordination shape. Verify by checking the prompt template or reading the resulting `intelligence.json` for a partner entity: no `renewal_risk` or `spend` fields should appear; `alignment` and `deliverables` fields should.
4. Meeting classification recognizes partner attendees. If a meeting attendee's email domain matches a partner account's domain, the meeting's entity context reflects the partner relationship. Verify with a real meeting that includes a known partner attendee.
5. A DB migration sets all existing accounts without an explicit `account_type` to `customer` as the default. Verify: `SELECT count(*) FROM accounts WHERE account_type IS NULL` returns 0 after migration.
6. Existing customer and internal accounts are unaffected. `cargo test` passes.

---

### I383 — AccountsPage three-group layout

1. The AccountsPage renders three named sections: **Your Book** (customer accounts), **Your Team** (internal accounts), **Your Partners** (partner accounts). The section names match exactly.
2. Each account appears in exactly one section, determined by its `account_type`. An account does not appear in more than one section.
3. Sections with zero accounts do not render. If the user has no partner accounts, "Your Partners" is not shown.
4. The existing parent/child hierarchy is preserved within each section. A parent customer account still shows its child accounts nested beneath it within "Your Book."
5. Search applies across all three sections simultaneously. Searching for an account name returns the result regardless of which section it's in.
6. The page uses the existing design system — no new layout patterns. Section headers use the existing editorial section rule/header treatment.

---

### I384 — Parent account portfolio intelligence

1. The AI enrichment prompt for any account that has child accounts includes: the `intelligence.json` of every direct child (or a summarized excerpt if the child count is large), key active signals for each child, and the parent's own signals (from meetings tagged to the parent and user edits on the parent entity).
2. The resulting `intelligence.json` for a parent account contains a `portfolio` field that is absent from leaf-node intelligence. The `portfolio` field contains: `health_summary` (portfolio-level health assessment), `hotspots` (array of child accounts needing attention with reason), `cross_bu_patterns` (signal types or topics appearing in 2+ children), and `portfolio_narrative` (AI-synthesized executive view).
3. Verify with a real parent account that has 3+ children with existing intelligence: open the account detail page. The portfolio section renders with real content — not placeholder text, not null values. `hotspots` contains at least one entry if any child has a risk signal.
4. When a child account's `intelligence.json` is updated (by any means — enrichment, user edit, signal cascade), the parent account is enqueued in `intel_queue` for re-enrichment. Verify: update a child's intelligence; within one intel_queue cycle, the parent's `intelligence.json` `updated_at` timestamp changes.
5. Leaf-node accounts (no children) are unaffected. Their enrichment prompt and `intelligence.json` shape are unchanged. Verify: `SELECT id FROM accounts WHERE id NOT IN (SELECT DISTINCT parent_id FROM accounts WHERE parent_id IS NOT NULL)` returns leaf accounts; check one — no `portfolio` field in its `intelligence.json`.

---

### I385 — Bidirectional entity hierarchy signal propagation

1. **Upward — basic propagation:** When a child account emits a signal, a derived signal is created for the parent account in `signal_events` within one propagation cycle. The derived signal has `source = 'propagation:hierarchy_up'` and `confidence = child_confidence * 0.6`. Verify with a known parent-child account pair.
2. **Upward — accumulation:** Two child accounts under the same parent each emit a signal of the same type within a 48-hour window. The parent's fused confidence for that signal type is higher than either individual derived signal. Verify by checking `signal_events` fusion result for the parent — the Bayesian log-odds fusion already handles this; confirm the outcome with real data.
3. **Upward — enrichment trigger:** When the parent's accumulated signals trigger the intel_queue (because new signals exist since last enrichment), the parent enrichment runs and produces updated portfolio intelligence. Verify: after two children emit signals, the parent's `entity_intel.updated_at` changes within one intel_queue cycle.
4. **Downward — fan-out:** When a parent account emits a signal with confidence ≥ 0.7, derived signals are created for all direct children in `signal_events` within one propagation cycle. Derived signals have `source = 'propagation:hierarchy_down'` and `confidence = parent_confidence * 0.5`. Verify with a known parent account by emitting a high-confidence signal.
5. **Downward — threshold gate:** A parent signal with confidence < 0.7 does NOT produce downward derived signals. Verify: emit a low-confidence signal on a parent; `signal_events` contains no `propagation:hierarchy_down` rows for its children.
6. **No loops:** Derived signals (source containing `propagation:hierarchy`) are not re-propagated. Verify: check `signal_events` after a propagation cycle — no `propagation:hierarchy` signal has itself spawned another `propagation:hierarchy` signal.
7. Downward propagation applies to direct children only. Grandchildren do not receive derived signals from this cycle. Verify: a three-level hierarchy (grandparent → parent → child); emit a signal on grandparent; only the parent (direct child) gets a derived signal, not the grandchild.

---

### I386 — Parent account detail page

1. Opening a parent account detail page (any account with children) renders a distinct **Portfolio** chapter as the primary content section. This chapter does not appear on leaf-node account pages.
2. The Portfolio chapter contains:
   - **Health summary** — portfolio-level narrative from `intelligence.json.portfolio.portfolio_narrative`
   - **Hotspots** — list of child accounts with active risk or opportunity signals, with a one-line reason per child. Sorted by signal recency/urgency. Each hotspot links to that child's detail page.
   - **Cross-BU patterns** — signal types or topics appearing in 2+ children, surfaced as a distinct callout. If no cross-BU patterns exist, this section is hidden (not an empty state).
3. Below the Portfolio chapter, the existing account intelligence sections render (the parent's own signals, meetings, actions) — the same content a leaf-node account would show for its own entity.
4. The child account list renders as a condensed view within the Portfolio chapter — each child shown with its name, type badge, and health indicator. Clicking a child navigates to that child's detail page.
5. Meetings tagged directly to the parent appear in the parent's meeting section. Meetings tagged to child accounts do NOT appear in the parent's meeting list. Verify: the parent's meeting list contains only meetings where the parent's `id` is in `meeting_entities`, not meetings linked to any child.
6. The page uses the existing design system and editorial layout patterns. The Portfolio chapter uses the existing chapter/section rule treatment. Hotspots use the existing callout/signal prose component. No new design patterns are invented.

---

## Issue Dependencies

```
I382 (partner entity type)
  └── required by I383 (three-group layout needs the type enum to exist)
  └── informs I384/I386 (partner accounts should not render portfolio sections
       regardless of whether they have children — partner ≠ portfolio holder)

I383 (AccountsPage grouping)
  └── addBlockedBy I382 — grouping depends on account_type being reliable

I384 (parent portfolio intelligence)
  └── addBlockedBy I385 — portfolio intelligence is most useful once child signals
       are propagating to the parent; do I385 first so the prompt has real
       signal data when portfolio enrichment runs for the first time

I385 (bidirectional propagation)
  └── independent — extends existing propagation rules, no other issues block it

I386 (parent detail page)
  └── addBlockedBy I384 — page renders from portfolio section of intelligence.json;
       that section doesn't exist until I384 ships
```

**Recommended build order:**
1. I382 (partner type + migration) — foundational, unblocks I383
2. I383 (AccountsPage grouping) — quick UI win, visible immediately
3. I385 (bidirectional propagation) — signal foundation, unblocks meaningful portfolio data
4. I384 (portfolio intelligence) — the AI layer, builds on I385 signal data
5. I386 (parent detail page) — the frontend surface, renders I384 output

---

## Ship criteria

All acceptance criteria above are met across all 5 issues. A real parent account with 3+ children renders a Portfolio chapter with a synthesized health summary, at least one hotspot if any child has a risk signal, and cross-BU patterns if applicable. BU signals propagate to the parent without user action. A high-confidence parent signal fans out to all direct children within one propagation cycle. Partner accounts render with a distinct badge. The AccountsPage shows three groups. No regressions on leaf-node account, person, or project pages.

### End-to-end smoke test (mandatory before tagging)

1. Clean app restart (`pnpm dev`). Open the AccountsPage. Confirm three sections render correctly — customer accounts in Your Book, internal in Your Team, partner accounts (if any) in Your Partners. If no partners exist, create one.
2. Open a partner account detail page. Confirm: partner badge is visible, intelligence section uses partner-appropriate vocabulary (no "renewal risk," no "spend"), no Portfolio chapter.
3. Open a parent customer account detail page (one with 3+ children). Confirm: Portfolio chapter renders with real data — health summary, at least one child in the hotspots list, portfolio narrative is not null or placeholder.
4. In the running app, edit a field on a child account. Wait one intel_queue cycle (≤2 min). Open the parent account detail page. Confirm: the parent's portfolio narrative reflects the updated child context (or at minimum, `entity_intel.updated_at` for the parent has changed since before the edit).
5. Check `signal_events` directly: `SELECT source, entity_id, created_at FROM signal_events WHERE source LIKE '%hierarchy%' ORDER BY created_at DESC LIMIT 20`. Confirm both `hierarchy_up` and `hierarchy_down` rows exist from recent propagation cycles.
