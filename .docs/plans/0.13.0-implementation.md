# 0.13.0 Implementation Plan — Meeting Intelligence

**Date:** 2026-02-19
**Issues:** I326, I327, I328, I330, I331, I332, I333
**ADR:** 0081 (Event-Driven Meeting Intelligence)
**Deferred from 0.12.1:** Lead Story → Up Next, Review+Priorities → Attention section

---

## Executive Summary

DailyOS shifts from schedule-based to event-driven meeting intelligence. Every meeting gets an intelligence record when detected on the calendar — days ahead, not day-of. The daily briefing assembles pre-computed intelligence instead of generating it. Signals drive incremental updates. The week page becomes a ±7-day intelligence timeline.

This is the largest backend change since 0.10.0 (signals). ~15 files touched in Rust, ~8 in React.

---

## Current State (What Exists)

| Component | Status | Location |
|-----------|--------|----------|
| Meeting classification with entity hints | Working (I336) | `google_api/classify.rs` |
| Meeting context gathering | Working (I305/I337) | `prepare/meeting_context.rs` |
| MeetingIntelligence struct | Working (ADR-0066) | `types.rs:1367` |
| Signal bus + signal_events table | Working (ADR-0080) | `signals/bus.rs`, migration 018 |
| Daily orchestrator (prepare_today) | Working | `prepare/orchestrate.rs:28` |
| Weekly orchestrator (prepare_week) | Working but summary-only | `prepare/orchestrate.rs:539` |
| IntelligenceQualityBadge | Basic (time-based) | `components/entity/IntelligenceQualityBadge.tsx` |
| Scheduler + cron jobs | Working | `scheduler.rs` |
| `account_id` on meetings_history | Still present in 40 files | I335 never shipped |
| Prep delivery to disk files | Working | `workflow/deliver.rs:954` |

**Critical dependency note:** I335 (entity-generic data model — replace `account` fields with `entities` arrays) was planned for 0.10.0 but never shipped. `account_id` still exists in 40 files. I328 (classification expansion) requires entity-generic resolution to work properly for internal team meetings. **We must ship I335 as Phase 0 of 0.13.0, or accept the tech debt and work around it.**

**Recommendation:** Include I335 as Phase 0. The `account_id` → `entities` migration is a prerequisite for I328's classification expansion (internal teams as entities). Doing it now prevents carrying the compat shim through 0.13.0's new code.

---

## Architecture: 5 Phases, Sequential with Parallel Frontend

### Phase 0: Entity-Generic Data Model (I335)
**Foundation. Must ship first. Everything else builds on this.**

### Phase 1: Meeting Intelligence Lifecycle (I326)
**Extract `meeting:prep` as independent operation. Intelligence state machine.**

### Phase 2: Advance Generation + Classification (I327 + I328)
**Wire into weekly orchestrator + calendar polling. Expand classification.**

### Phase 3: Surface Transformation (I330 + I331 + deferred 0.12.1 items)
**Week page ±7-day timeline. Daily briefing assembly model. Up Next + Attention.**

### Phase 4: Signal Integration + Collaboration (I332 + I333)
**Signal-triggered refresh. Share/draft agenda actions.**

---

## Phase 0: Entity-Generic Data Model (I335)

**Goal:** Replace singular `account` fields with `entities` arrays throughout the pipeline. Drop `meetings_history.account_id`.

**Why first:** Every Phase 1-4 file we touch still has `meeting.account` / `account_id` references. If we build new intelligence lifecycle code on the old model, we double the migration work later. Bite the bullet now.

### Backend Changes

**Migration (new SQL):**
```sql
-- Drop account_id from meetings_history (already has junction table)
ALTER TABLE meetings_history DROP COLUMN account_id;
```
Note: Migration 023 already exists (`023_drop_meeting_account_id.sql`) but may not be active. Verify.

**Struct changes:**
| File | Change |
|------|--------|
| `types.rs` | `ClassifiedMeeting`: remove `account: Option<String>`, ensure `resolved_entities` is primary |
| `types.rs` | `DirectiveMeeting`: remove `account`, use `resolved_entities` |
| `types.rs` | `Meeting`: remove `account`, `account_id`; add `entities: Option<Vec<LinkedEntity>>` |
| `prepare/entity_resolver.rs` | Remove `resolve_account_compat()`, `signal_explicit_assignment` |
| `hygiene.rs` | Remove `fix_orphaned_meetings()` (depends on `account_id`) |
| `db.rs` | Remove `update_meeting_account()` |
| `workflow/deliver.rs` | `build_prep_json()`: write `entities` array instead of `account` field |
| `workflow/deliver.rs` | `deliver_schedule()`: write `entities` in schedule.json |

**Frontend changes:**
| File | Change |
|------|--------|
| `types/index.ts` | `Meeting`: remove `account`, ensure `linkedEntities` is used everywhere |
| All components using `meeting.account` | Replace with `meeting.linkedEntities?.[0]?.name` or entity-aware rendering |

**Acceptance:** `cargo test` passes, `cargo clippy -- -D warnings` clean, `pnpm build` compiles, no code references `meetings_history.account_id` or `Meeting.account`.

**Risk:** High — touches 40 files. But the migration 023 already exists, suggesting this was partially attempted. Need to verify what state it's in.

**Estimated scope:** ~40 file touches, mostly mechanical find-replace. 2-3 agents in parallel (backend structs, backend pipeline, frontend).

---

## Phase 1: Meeting Intelligence Lifecycle (I326)

**Goal:** Extract `meeting:prep` from the daily orchestrator into an independent, idempotent operation. Add intelligence state tracking.

### 1A: Intelligence State Schema

**New DB columns on `meetings_history`:**
```sql
ALTER TABLE meetings_history ADD COLUMN intelligence_state TEXT DEFAULT 'detected';
-- Values: detected, enriching, enriched, refreshing, captured, archived
ALTER TABLE meetings_history ADD COLUMN intelligence_quality TEXT DEFAULT 'sparse';
-- Values: sparse, developing, ready, fresh
ALTER TABLE meetings_history ADD COLUMN last_enriched_at TEXT;
ALTER TABLE meetings_history ADD COLUMN signal_count INTEGER DEFAULT 0;
ALTER TABLE meetings_history ADD COLUMN has_new_signals INTEGER DEFAULT 0;
ALTER TABLE meetings_history ADD COLUMN last_viewed_at TEXT;
```

**New Rust structs (in `types.rs`):**
```rust
pub enum IntelligenceState {
    Detected, Enriching, Enriched, Refreshing, Captured, Archived
}

pub enum QualityLevel {
    Sparse, Developing, Ready, Fresh
}

pub enum Staleness {
    Current,  // < 12h
    Aging,    // 12-48h
    Stale,    // 48h+
}

pub struct IntelligenceQuality {
    pub level: QualityLevel,
    pub signal_count: u32,
    pub last_enriched: Option<String>,
    pub has_entity_context: bool,
    pub has_attendee_history: bool,
    pub has_recent_signals: bool,
    pub staleness: Staleness,
    pub has_new_signals: bool,
}
```

### 1B: Independent `generate_meeting_intelligence` Function

**New file:** `src-tauri/src/intelligence_lifecycle.rs`

Extract from `prepare/orchestrate.rs` + `prepare/meeting_context.rs` + `workflow/deliver.rs`:

```rust
/// Generate or refresh intelligence for a single meeting.
/// Idempotent: calling twice does incremental update, not duplicate.
pub async fn generate_meeting_intelligence(
    state: &AppState,
    workspace: &Path,
    meeting_id: &str,
    force_full: bool,  // false = incremental if intelligence exists
) -> Result<IntelligenceQuality, ExecutionError>
```

**Logic:**
1. Load meeting from `meetings_history` by ID
2. If `intelligence_state` is `enriched` and `!force_full`:
   - Check for new signals since `last_enriched_at`
   - If no new signals → return current quality (no work)
   - If new signals → set state to `refreshing`, do incremental update
3. If no intelligence exists or `force_full`:
   - Set state to `enriching`
   - Run classification (if not already classified)
   - Run entity resolution
   - Gather meeting context (same as `gather_meeting_context()`)
   - **Mechanical-first:** Assess quality from DB alone (attendee history, entity context, open actions, past meetings). If quality ≥ Developing, write to `prep_context_json` without AI call.
   - If AI available and meeting is entity-tier or person-tier: run AI enrichment for narrative synthesis
   - Write intelligence to `prep_context_json` (SQLite, permanent)
   - Optionally write prep file to disk (for today's meetings, backward compat)
   - Set state to `enriched`, update `last_enriched_at`, `intelligence_quality`, `signal_count`
4. Return `IntelligenceQuality`

**Mechanical-first quality assessment (no AI call):**
```rust
pub fn assess_intelligence_quality(meeting: &DbMeeting, db: &Database) -> IntelligenceQuality {
    let has_entity = meeting has linked entities in junction table;
    let has_attendees = meeting.attendees is non-empty;
    let has_history = past meetings with same entity exist;
    let has_actions = open actions linked to entity exist;
    let signal_count = count signals for entity from signal_events;

    let level = match (has_entity, has_history, signal_count > 2) {
        (true, true, true) => QualityLevel::Ready,   // entity + history + signals
        (true, true, _)    => QualityLevel::Developing, // entity + history
        (true, _, _)       => QualityLevel::Developing, // entity linked
        _                  => QualityLevel::Sparse,     // calendar data only
    };
    // ... staleness from last_enriched_at
}
```

### 1C: New Tauri Command

```rust
#[tauri::command]
pub async fn generate_meeting_intelligence(
    state: State<'_, Arc<AppState>>,
    meeting_id: String,
) -> Result<IntelligenceQuality, String>
```

### 1D: Update `get_meeting_intelligence` Command

Add `IntelligenceQuality` to the response. The frontend `MeetingIntelligence` type gains:
```typescript
intelligenceQuality?: {
    level: "sparse" | "developing" | "ready" | "fresh"
    signalCount: number
    lastEnriched?: string
    hasEntityContext: boolean
    hasAttendeeHistory: boolean
    hasRecentSignals: boolean
    staleness: "current" | "aging" | "stale"
    hasNewSignals: boolean
}
```

**Acceptance criteria (from backlog):**
1. `meeting:prep` callable independently (not just from daily orchestrator) ✓
2. Intelligence writes to SQLite permanently ✓
3. Calling on already-enriched meeting does incremental update ✓
4. State tracked per-meeting ✓
5. Pre-meeting refresh works on any meeting ✓
6. No regression on existing daily briefing pipeline ✓
7. Meeting reaches Developing quality without any AI call ✓

**Files touched:** ~6 Rust files (new `intelligence_lifecycle.rs`, modified `db.rs`, `commands.rs`, `types.rs`, migration, `workflow/deliver.rs`)

---

## Phase 2: Advance Generation + Classification Expansion (I327 + I328)

### 2A: Classification Expansion (I328)

**File:** `google_api/classify.rs`

Update classification tiers:

| Current Tier | Current Types | New Tier | New Types |
|-------------|---------------|----------|-----------|
| Account-prep | customer, qbr, partnership, demo | Entity intelligence | customer, qbr, partnership, demo, team_sync (with team entity) |
| Person-prep | internal, team_sync, one_on_one | Person intelligence | one_on_one, internal (small group, no entity) |
| No-prep | personal, all_hands, training | Minimal intelligence | training, personal |
| — | — | Skip | all_hands (50+ attendees) |

**Key change:** `classify_meeting_multi()` returns a new field:
```rust
pub enum IntelligenceTier {
    Entity,   // Full AI enrichment
    Person,   // Lightweight prompt
    Minimal,  // Mechanical only, no AI call
    Skip,     // No intelligence (all_hands)
}
```

The `ClassifiedMeeting` struct gains `intelligence_tier: IntelligenceTier`.

### 2B: Weekly Orchestrator — Individual Intelligence (I327)

**File:** `prepare/orchestrate.rs` — `prepare_week()` function

**Current flow:** Fetch calendar → classify → gaps → proactive scan → write `week-directive.json`

**New flow:**
1. Fetch calendar for forecast window (current week + next week, ~10 business days)
2. Classify all meetings (with expanded classification)
3. For each meeting (excluding Skip tier):
   - Check if intelligence exists in `meetings_history`
   - If missing: queue `generate_meeting_intelligence()` to background IntelligenceQueue
   - If exists but stale (>48h): queue incremental refresh
4. **Entity-clustered batching:** Group meetings by primary entity. For meetings in the same entity cluster, share entity context in a single AI call instead of N calls.
5. Gap analysis + focus block suggestions (unchanged)
6. Proactive scan (unchanged)
7. Write `week-directive.json` (unchanged)

**Batching strategy:**
```rust
// Group meetings by primary entity
let clusters: HashMap<String, Vec<&ClassifiedMeeting>> = group_by_entity(meetings);
// For each cluster: generate intelligence for all meetings in one AI call
for (entity_id, cluster_meetings) in clusters {
    generate_clustered_intelligence(state, workspace, entity_id, cluster_meetings).await?;
}
```

Target: ~10-15 AI calls for 50 meetings (entity-clustered), not 50.

### 2C: Calendar Polling — Reactive Intelligence

**File:** `scheduler.rs` or new `calendar_watcher.rs`

Currently, calendar polling detects changes but doesn't trigger enrichment. Add:

```rust
// In the calendar poll handler:
async fn handle_calendar_change(state: &AppState, change: CalendarChange) {
    match change {
        CalendarChange::NewMeeting(meeting) => {
            // Classify + generate intelligence asynchronously
            generate_meeting_intelligence(state, workspace, &meeting.id, false).await;
        }
        CalendarChange::MeetingUpdated(meeting) => {
            // Re-classify, re-resolve entity, incremental refresh
            generate_meeting_intelligence(state, workspace, &meeting.id, true).await;
        }
        CalendarChange::MeetingCancelled(meeting_id) => {
            // Mark intelligence record cancelled
            db.update_intelligence_state(&meeting_id, IntelligenceState::Archived);
        }
    }
}
```

### 2D: Daily Orchestrator Refactor (I331 — partial)

**File:** `prepare/orchestrate.rs` — `prepare_today()`

**Current:** 7-step pipeline that generates preps from scratch.

**New:** Lightweight assembly pipeline:
1. Check today's meetings — intelligence should already exist
2. For any meeting missing intelligence: call `generate_meeting_intelligence()` (edge case)
3. For meetings with intelligence > 12h old: signal-aware refresh
4. Fetch emails, sync actions (unchanged)
5. Generate overview narrative (over pre-computed intelligence, not raw calendar)
6. Write schedule.json, overview.json (unchanged delivery)

**The key change:** Step 3 (meeting context gathering) becomes a freshness check + optional refresh, not a full generation. Step 5 (AI enrichment) narrates over existing intelligence summaries.

**Acceptance criteria:**
1. Weekly run generates individual intelligence for all meetings in forecast window ✓
2. Daily run does NOT generate preps from scratch ✓
3. Calendar polling triggers meeting:prep for new meetings ✓
4. Meetings added mid-week get intelligence via polling ✓
5. Daily briefing generation time reduced ✓
6. Week page shows intelligence for meetings 10 business days out ✓
7. Weekly run uses entity-clustered batching ✓

**Files touched:** ~5 Rust files (`classify.rs`, `orchestrate.rs`, `scheduler.rs` or new `calendar_watcher.rs`, `intelligence_lifecycle.rs` updates)

---

## Phase 3: Surface Transformation (I330 + I331 + deferred 0.12.1)

### 3A: Week Page — ±7-Day Intelligence Timeline (I330)

**File:** `src/pages/WeekPage.tsx`

**Current structure (after 0.12.1 cuts):**
- "The Three" chapter: top priorities
- "The Shape" chapter: 5-day density bars

**New structure:**
- **"The Three" chapter** — Unchanged (top priorities)
- **"The Timeline" chapter** (replaces "The Shape"):
  - ±7 days centered on today
  - Past meetings (up to 7 days back): title, entity, quality badge, outcome summary
  - Today's meetings: quality badge, "new signals" dot, temporal state
  - Upcoming meetings (up to 7 days forward): quality badge, readiness state
  - Past section beyond 2 days collapsed by default, expandable
  - Click any meeting → navigate to `/meeting/$meetingId`
  - "Review last meeting →" link on upcoming meetings with prior meeting in same series
- **Readiness summary** — Intelligence-quality-driven:
  - "3 meetings ready, 2 building, 1 sparse" (replaces "X/Y prepped")
  - "Thursday QBR intelligence stale — refresh available"

**New data source:**
```typescript
// New Tauri command
const timeline = await invoke<TimelineMeeting[]>("get_meeting_timeline", {
    daysBefore: 7,
    daysAfter: 7,
});

interface TimelineMeeting {
    id: string
    title: string
    startTime: string
    endTime: string
    meetingType: string
    intelligenceQuality: IntelligenceQuality
    hasOutcomes: boolean
    outcomeSummary?: string  // 1-line for past meetings
    entities: LinkedEntity[]
    hasNewSignals: boolean
    priorMeetingId?: string  // Same series/entity → "Review last meeting"
}
```

**New Tauri command:** `get_meeting_timeline` — queries `meetings_history` for ±7 days, joins with intelligence quality + outcomes.

### 3B: Daily Briefing Intelligence Assembly (I331)

**File:** `src/components/dashboard/DailyBriefing.tsx`, `BriefingMeetingCard.tsx`

**Schedule section changes:**
- Replace "X/Y prepped" stat with intelligence quality summary
- Each meeting row shows IntelligenceQualityBadge with tooltip (already started in 0.12.1)
- "New signals" blue dot on meetings that received signals since morning briefing
- Inline intelligence brief (2-line summary from prep.intelligenceSummary) on entity-tier meetings
- "Refresh" button scope label changes: "Morning refresh" not "Run briefing"

**IntelligenceQualityBadge evolution:**
Currently: simple time-based (fresh/recent/stale from `enrichedAt`)
New: level-based from backend `IntelligenceQuality`:
```typescript
// Updated badge props
interface IntelligenceQualityBadgeProps {
    quality?: IntelligenceQuality  // New: structured quality from backend
    enrichedAt?: string            // Backward compat
    showLabel?: boolean
}
```

Badge vocabulary:
- Sparse (gray) — little context
- Building (amber) — accumulating
- Ready (sage) — confident
- Fresh (sage + check) — just refreshed
- New signals (blue dot overlay)

### 3C: Deferred 0.12.1 Structural Builds

**Lead Story → Up Next (DailyBriefing.tsx):**
- Remove featured meeting concept
- "Up Next" section shows the next upcoming meeting with its intelligence brief
- Not a hero card — a compact row with quality badge + 2-line summary + "View briefing →"

**Review + Priorities → Attention section:**
- Current separate sections for proposed actions + pending actions + emails
- Merge into single "Attention" section with filter logic: meeting-relevant items first, then quick wins
- Items grouped by: "Before your next meeting" → "Action needed" → "For review"

**Files touched:** ~6 React files (`WeekPage.tsx`, `DailyBriefing.tsx`, `BriefingMeetingCard.tsx`, `IntelligenceQualityBadge.tsx`, new `TimelineSection.tsx`, types update)

---

## Phase 4: Signal Integration + Collaboration (I332 + I333)

### 4A: Signal-Triggered Meeting Intelligence Refresh (I332)

**Files:** `signals/bus.rs` (or new `signals/meeting_signals.rs`), `scheduler.rs`

**Signal → Meeting mapping:**

| Signal | Effect |
|--------|--------|
| Email mentioning meeting attendees/entity | Mark meeting `has_new_signals = 1` |
| Calendar change (attendee, time, description) | Re-classify + trigger refresh |
| Entity intelligence updated | Flag all meetings for that entity |
| User edits agenda/notes | Incorporate on next refresh |
| Transcript processed | Set state to `captured` |

**Implementation:**
1. New function: `propagate_signal_to_meetings(signal: &SignalEvent, db: &Database)`
   - Maps signal's `entity_id` to meetings via junction table
   - Sets `has_new_signals = 1` on affected meetings
2. Hook into existing `emit_signal_and_propagate()` — add meeting propagation step
3. Pre-meeting refresh: scheduler checks meetings starting in 2h, if `has_new_signals`, trigger refresh
4. Blue dot UI: `has_new_signals` flag drives UI indicator
5. Viewing meeting detail sets `last_viewed_at`, clears `has_new_signals`

**Eventual consistency model (per ADR-0081):**
- Signal recorded immediately
- Meeting flagged immediately (`has_new_signals`)
- Full re-enrichment deferred to natural checkpoints (pre-meeting, daily run, user refresh)
- NOT real-time re-enrichment on every signal

### 4B: Meeting Intelligence Collaboration (I333)

**File:** `src/pages/MeetingDetailPage.tsx`, new `commands.rs` additions

**Actions (on MeetingDetailPage folio bar for future meetings):**

1. **"Share Intelligence"**
   - Generate clean, shareable summary (sans internal-only context)
   - Copy to clipboard as formatted text
   - Uses existing `intelligenceSummary` + `risks` + `talkingPoints`

2. **"Draft Agenda Email"**
   - Opens AgendaDraftDialog (partially exists)
   - AI generates email draft with proposed agenda items
   - Addressed to meeting attendees
   - Uses Gmail draft API or copy-to-clipboard

3. **"Request Input"**
   - Template-based message requesting attendees add topics
   - Available when meeting is 3+ days out

**Contextual visibility:**
- "Share" available when quality ≥ Ready
- "Draft Agenda" when user has agenda items
- "Request Input" when meeting is 3+ days out

**Files touched:** ~3 Rust files (signal propagation, scheduler pre-meeting check), ~2 React files (MeetingDetailPage folio actions, share dialog)

---

## Team Structure

**6 agents across 4 phases (sequential phases, parallel agents within phases):**

### Phase 0 (I335): 3 agents, ~2 hours
| Agent | Scope |
|-------|-------|
| `data-model-backend` | Rust struct changes: types.rs, entity_resolver.rs, hygiene.rs, db.rs. Verify migration 023. |
| `data-model-pipeline` | Pipeline changes: deliver.rs (build_prep_json, deliver_schedule), orchestrate.rs, meeting_context.rs. |
| `data-model-frontend` | Frontend: types/index.ts, all components using `meeting.account`. Verify schedule.json consumers. |

### Phase 1 (I326): 2 agents, ~3 hours
| Agent | Scope |
|-------|-------|
| `lifecycle-backend` | New intelligence_lifecycle.rs, DB migration (intelligence columns), types.rs structs, assess_intelligence_quality(), commands.rs updates. |
| `lifecycle-tests` | Unit tests for intelligence lifecycle: state transitions, mechanical quality assessment, idempotent refresh, incremental update. |

### Phase 2 (I327 + I328): 2 agents, ~3 hours
| Agent | Scope |
|-------|-------|
| `advance-gen` | Weekly orchestrator refactor (prepare_week individual intelligence), daily orchestrator refactor (assembly model), entity-clustered batching. |
| `classification` | classify.rs IntelligenceTier, calendar polling → intelligence trigger, scheduler pre-meeting refresh. |

### Phase 3 (I330 + I331 + deferred): 3 agents, ~4 hours
| Agent | Scope |
|-------|-------|
| `week-page` | WeekPage.tsx timeline redesign, new get_meeting_timeline command, TimelineSection component. |
| `briefing` | DailyBriefing.tsx assembly model, IntelligenceQualityBadge evolution, Up Next section, Attention section merge. |
| `meeting-detail` | MeetingDetailPage quality indicators, per-meeting refresh action, "new signals" indicator. |

### Phase 4 (I332 + I333): 2 agents, ~2 hours
| Agent | Scope |
|-------|-------|
| `signals` | Signal → meeting propagation, pre-meeting refresh scheduler, has_new_signals flag, blue dot clearing on view. |
| `collaboration` | Share Intelligence action, Draft Agenda enhancement, Request Input template. |

---

## Verification Checklist

### Per-phase gates (must pass before next phase starts):

**Phase 0:** `cargo test` + `cargo clippy -- -D warnings` + `pnpm build` clean. Zero references to `meetings_history.account_id` or `Meeting.account` in non-migration code.

**Phase 1:** New tests for intelligence lifecycle. `generate_meeting_intelligence()` works independently. Mechanical quality assessment reaches Developing without AI.

**Phase 2:** Weekly run generates individual intelligence for 10+ meetings. Daily run completes in <60s. Calendar polling triggers intelligence for new meetings.

**Phase 3:** Week page shows ±7-day timeline with quality badges. Daily briefing shows intelligence quality summary. Click any meeting → MeetingDetailPage.

**Phase 4:** Signal events propagate to meetings. Blue dot appears on meetings with new signals. Share Intelligence generates clean output.

### Final verification:
```bash
cargo test                                    # All Rust tests pass
cargo clippy --manifest-path src-tauri/Cargo.toml --workspace --all-features --lib --bins -- -D warnings  # Clean
npx tsc --noEmit                              # TypeScript clean
pnpm test                                     # Frontend tests pass
```

### Grep confirmations:
- Zero: `meetings_history.account_id` (outside migrations)
- Zero: `Meeting.account` (outside compat)
- Present: `IntelligenceState`, `QualityLevel`, `assess_intelligence_quality`
- Present: `generate_meeting_intelligence` in commands.rs
- Present: `get_meeting_timeline` in commands.rs
- Present: `propagate_signal_to_meetings` in signals/

---

## Risk Register

| Risk | Impact | Mitigation |
|------|--------|------------|
| I335 breaks 40 files simultaneously | Build failure | Phase 0 agents work in parallel on non-overlapping files. Gate on `cargo check` before proceeding. |
| Weekly run times out on 50+ meetings | User sees incomplete intelligence | IntelligenceQueue background processing. External meetings first. Entity-clustered batching reduces AI calls. |
| Mechanical-only quality is too sparse | Users see "Sparse" everywhere | Ensure entity linking + attendee history alone reaches "Developing". Only all_hands and truly unknown meetings stay Sparse. |
| Calendar polling races with weekly run | Duplicate enrichment | `generate_meeting_intelligence()` is idempotent — calling twice is a no-op if no new signals. |
| Frontend type changes break existing pages | Runtime errors | TypeScript strict mode catches at compile time. IntelligenceQuality is optional field for backward compat. |

---

## What This Does NOT Include

- **Auto-run briefing on app launch** — Deferred to Phase 2 (future). Keep "Prepare my day" button.
- **Actions meeting-centric primary view** — Deferred. Would require significant ActionsPage rework.
- **Action auto-expiry at 30 days** — Deferred. Simple but orthogonal.
- **I351 person detail actions** — Deferred. Needs 1:1 heuristic resolved first.
- **Embedding-based context relevance scoring** — Already exists in entity_resolver. No new work needed.
