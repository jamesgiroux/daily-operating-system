# Always-Live Briefing Plan

**Goal:** The app never shows an empty state with a "Run Briefing" button. On first load, it displays whatever intelligence exists — meetings with quality badges, live-computed focus, actions from SQLite. The narrative/email portions fill in via auto-triggered background refresh.

---

## Current State (what blocks this)

The `get_dashboard_data` command returns `"empty"` when `schedule.json` doesn't exist. The frontend shows `DashboardEmpty` with the "Prepare my day" button. The user must click to generate.

But with 0.13.0's intelligence lifecycle, meetings already have intelligence in SQLite from the weekly run and calendar polling. The data exists — it's just not surfaced until the daily run writes `schedule.json`.

## What Needs to Change

### 1. Backend: `get_dashboard_data` fallback to live data

**File:** `src-tauri/src/commands.rs` — `get_dashboard_data()`

**Current:** If `schedule.json` doesn't load → return `DashboardResult::Empty`.

**New:** If `schedule.json` doesn't load → build `DashboardData` from live sources:

```
schedule.json missing?
  ├─ Meetings: invoke get_meeting_timeline(0, 1) for today's meetings from SQLite
  ├─ Overview: { greeting: time-based, date: today, summary: "N meetings today", focus: null }
  ├─ Actions: query SQLite directly (non-briefing + proposed actions)
  ├─ Emails: null (not yet fetched)
  ├─ Email narrative: null
  ├─ Focus: compute_focus_capacity() (already live)
  └─ Return DashboardResult::Success with freshness: "stale"
```

The key insight: `DashboardResult::Empty` should only appear when there are truly zero meetings (no calendar connected, no data at all). If meetings exist in SQLite, show them.

### 2. Backend: Auto-trigger morning refresh on first load

**File:** `src-tauri/src/commands.rs` — `get_dashboard_data()`

When building from live data (no schedule.json), also kick off the daily run in the background:

```rust
// No schedule.json — return live data AND trigger background refresh
if !schedule_exists {
    // Build live dashboard data (meetings from SQLite, actions from SQLite, etc.)
    let live_data = build_live_dashboard_data(state)?;

    // Auto-trigger daily refresh in background
    let state_clone = state.inner().clone();
    let app_handle = app_handle.clone();
    tokio::spawn(async move {
        let executor = Executor::new(state_clone, app_handle);
        let _ = executor.run_workflow(WorkflowId::Today, ExecutionTrigger::Auto).await;
    });

    return Ok(DashboardResult::Success {
        data: live_data,
        freshness: DataFreshness::Stale, // signals "morning refresh running"
    });
}
```

The frontend already listens for `workflow-completed` events and auto-refreshes when they fire. So the flow becomes:

1. User opens app → sees live meetings + quality badges immediately
2. Background refresh runs (email fetch, action sync, narrative generation)
3. `workflow-completed` event fires → `useDashboardData` reloads → full briefing appears

### 3. Frontend: Replace empty state with live state

**File:** `src/components/dashboard/DashboardEmpty.tsx` → becomes `DashboardLive.tsx` concept

**Current:** Big "Prepare my day" button, empty illustration.

**New:** When `freshness === "stale"` and data exists (meetings from SQLite):
- Show today's meetings with quality badges (same as briefing schedule section)
- Show "Morning refresh in progress..." subtle indicator
- Show actions from SQLite
- Email section shows "Emails not yet fetched"
- Overview section shows time-based greeting + meeting count (no AI narrative yet)

When there's truly no data (no Google auth, no meetings at all):
- Show onboarding/connection prompt (existing behavior for no-auth state)

### 4. Frontend: Remove "Prepare my day" as primary CTA

**File:** `src/components/dashboard/DailyBriefing.tsx`

- The folio bar keeps a "Refresh" button (same as now) for manual refresh
- No separate empty state with a blocking CTA
- The `DashboardPage` in `router.tsx` changes: `status: "empty"` is eliminated for the meeting-data-exists case

### 5. Week page: Already done

The week page timeline already calls `get_meeting_timeline` which reads from SQLite. "The Three" priorities need the generated `week-overview.json`, but the timeline works without it. Show timeline immediately, show "Priorities available after weekly refresh" for the narrative section.

---

## Implementation: 2 agents

### Agent `live-backend`
- Modify `get_dashboard_data()` to build live `DashboardData` from SQLite when `schedule.json` is missing
- Add `build_live_dashboard_data()` helper that queries: today's meetings from `meetings_history`, actions from `actions` table, compute focus capacity
- Auto-trigger daily workflow in background when returning live data
- Add `ExecutionTrigger::Auto` variant if it doesn't exist

### Agent `live-frontend`
- Update `DashboardPage` in `router.tsx`: when `status === "empty"` but Google auth exists, show `DailyBriefing` with stale freshness
- Update `DailyBriefing.tsx`: handle `freshness === "stale"` — show meetings + "Morning refresh in progress" indicator, hide email/narrative sections until data arrives
- Update `DashboardEmpty.tsx`: only show for no-auth / no-calendar state
- Remove "Prepare my day" as blocking CTA — it becomes a subtle "Refresh" in the folio bar

---

## Verification

- App opens with no `schedule.json` → shows today's meetings with quality badges
- Background refresh auto-triggers → briefing enriches within 30-60s
- After refresh completes → full briefing with narrative, emails, actions
- No Google auth → shows connection prompt (existing behavior)
- Week page shows timeline immediately, priorities fill in after weekly run
