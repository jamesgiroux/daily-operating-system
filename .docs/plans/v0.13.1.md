# v0.13.1 Version Brief

**Thesis:** Email is an intelligence input, not a display surface. DailyOS doesn't show you emails — it tells you what your emails mean. Every email that enters the system is AI-processed, resolved to an entity, and synthesized with existing intelligence to produce contextual understanding you can act on. The mechanical three-tier sort is bootstrap scaffolding; the real product is the contextual distillation that connects email to what you already know about your work. A chief of staff reads your email and says "Jack is confirming the Acme EBR agenda for Thursday — this aligns with the renewal discussion from Tuesday." That's the bar. (ADR-0085)

**Status:** Planning.

---

## Scope

### In

| ID | Title | Area |
|----|-------|------|
| I365 | Inbox-anchored email fetch — `in:inbox` replaces `is:unread newer_than:1d` | Backend / Gmail API |
| I366 | Inbox reconciliation — vanished emails removed from DailyOS on each poll | Backend / Pipeline |
| I367 | Mandatory email enrichment — every email AI-processed, retry on failure | Backend / Pipeline |
| I368 | Persist email metadata to SQLite — DB as source of truth, not JSON files | Backend / DB |
| I369 | Contextual email synthesis — entity-aware smart summaries | Backend / Intelligence |
| I370 | Thread position refresh — detect user replies between polls | Backend / Gmail API |
| I371 | Meeting email context rendering — wire recentEmailSignals to meeting detail UI | Frontend / UX |
| I372 | Email-entity signal compounding — email signals flow into entity intelligence | Backend / Signals |
| I373 | Email sync status indicator — show last fetch time, stage, error state | Frontend / UX |
| I374 | Email dismissal learning — dismissed senders/types adjust future classification | Backend / Intelligence |
| I375 | Refresh button audit — design continuity with add buttons + action/surface alignment | UX / Code Quality |
| I386 | Calendar lifecycle gaps — future meeting cancellation detection, rescheduling sync, continuous future polling | Backend / Calendar |

### Explicitly out

- Email reply/compose from within DailyOS (still not an email client)
- Email body storage (only metadata + extracted intelligence persisted)
- Email search/filter on the EmailsPage (useful but not blocking — v0.14.0 candidate)
- Changes to the email page editorial layout (I358 is done; this version changes data quality, not page structure)
- New integrations
- Changes to meeting intelligence or weekly forecast surfaces (those are 0.13.0)

---

## Acceptance Criteria

Each criterion must be verified with real data in the running app. Compilation is not acceptance. Clippy passing is not acceptance. Types aligning is not acceptance. A criterion is met when you can observe the described behavior with your own eyes in the running app, with real Gmail data, after a full `pnpm dev` restart. If an agent reports an issue "done" but hasn't rebuilt and visually verified the behavior described below, it is not done.

---

### I365 — Inbox-anchored email fetch

1. Open Settings → Google section. Confirm email polling is active.
2. Read an email in Gmail (mark it as read) but do NOT archive it. Wait one poll cycle (≤15 min). Open DailyOS. The email still appears on the email page — it was not filtered out by `is:unread`.
3. Archive that email in Gmail. Wait one poll cycle. The email no longer appears on the email page.
4. Check logs: the Gmail API query contains `in:inbox`, not `is:unread newer_than:1d`.
5. The configurable time window (`newer_than:Xd`) defaults to 3 days. Verify emails up to 3 days old appear if still in inbox.
6. The `unread` status is preserved as metadata on the email object — verify `email.isUnread` (or equivalent) is `true` for unread emails and `false` for read emails, even though both are fetched.

---

### I366 — Inbox reconciliation

1. DailyOS shows 10 emails. Archive 3 in Gmail. After the next poll, DailyOS shows 7 emails.
2. The `email_threads` table marks threads for the 3 vanished emails with `resolved_at` timestamp.
3. Stale `email_signals` for vanished emails are marked inactive (not deleted — they're historical intelligence).
4. "Replies Needed" does not show threads for emails that have been archived in Gmail.
5. If an email reappears in the inbox (un-archived), it shows up again on the next poll.

---

### I367 — Mandatory email enrichment

1. Connect Gmail for the first time. The initial fetch produces mechanically classified emails (bootstrap). Within 2 minutes, AI enrichment runs automatically — verify by checking that email summaries, sentiment, and entity resolution appear without any manual action.
2. Deliberately kill the Claude process during enrichment (simulate failure). On the next poll cycle, the failed emails are retried — verify they eventually get enriched.
3. Every email on the email page has either: a contextual summary (enriched) OR a "Processing" indicator (enrichment in progress). No email should show raw sender+subject with no intelligence context in the steady state.
4. The `semanticEmailReclass` feature flag is removed from the codebase. `grep -r "semanticEmailReclass" src-tauri/src/` returns 0 results.
5. Check the enrichment queue: emails in `failed` state are retried with exponential backoff (verify via logs showing retry attempts with increasing delay, max 3 attempts).
6. The enrichment state for each email is tracked: `pending` → `enriching` → `enriched` or `failed`. Verify by querying the emails table.

---

### I368 — Persist email metadata to SQLite

1. An `emails` table exists in the database with columns: `email_id`, `thread_id`, `sender_email`, `sender_name`, `subject`, `snippet`, `priority`, `is_unread`, `received_at`, `enrichment_state`, `last_seen_at`, `entity_id`, `entity_type`, `contextual_summary`, `created_at`, `updated_at`.
2. After a poll cycle, query the DB: `SELECT count(*) FROM emails` returns a count matching the number of emails fetched. The DB is the source of truth.
3. `_today/data/emails.json` is still written (for backward compatibility with frontend) but is generated FROM the database, not the other way around. Verify: delete `emails.json`, trigger a refresh (NOT a Gmail fetch), and confirm `emails.json` is regenerated from DB contents. If the file can only be produced by fetching from Gmail, the DB is not the source of truth.
4. Email data survives across days. Open the app on Tuesday, see Monday's emails that are still in the inbox. Verify by checking `emails.received_at` includes dates older than today.
5. Entity detail pages (account, person) can query email history: open an account detail, see emails from that account's domain across multiple days — not just today's snapshot.

---

### I369 — Contextual email synthesis

1. Receive an email from a known contact at a known account (e.g., Jack at Acme). The email summary on the email page reads something like: "Jack is confirming the agenda for Thursday's EBR. This relates to the renewal discussion from your last meeting." NOT: "Email from Jack about EBR Agenda."
2. Receive an email from an unknown sender with no entity match. The summary is still useful ("New inquiry about enterprise pricing from an unknown contact at example.com") but acknowledges the lack of entity context.
3. Receive a low-information email (e.g., "Sounds good, thanks"). The summary says something like: "Jeff acknowledged your last message about the Medico expansion. No new information. Monitor." NOT: "Jeff sent a one-line reply."
4. The synthesis prompt includes: the email content, the resolved entity's current intelligence (from `entity_intel`), recent meeting history with the sender, and active signals for the entity. Verify by adding a debug log that prints the assembled prompt for one email — confirm it contains real entity data (account name, recent meeting date, signal text), not empty placeholders or nulls.
5. Synthesis runs as part of the enrichment pipeline (I367), not as a separate pass. Every enriched email has a `contextual_summary` in the DB. Verify: `SELECT count(*) FROM emails WHERE enrichment_state = 'enriched' AND contextual_summary IS NULL` returns 0.

---

### I370 — Thread position refresh

1. DailyOS shows a thread in "Replies Needed" (ball in your court). Reply to it in Gmail. After the next poll cycle (≤15 min), the thread disappears from "Replies Needed."
2. Verify by checking `email_threads.user_is_last_sender` flipped from 0 to 1 for the thread.
3. The poll cycle queries recent sent mail (or thread state) to detect replies — not just incoming mail. Verify via logs.
4. If the other party replies again after your reply, the thread reappears in "Replies Needed" on the next poll.

---

### I371 — Meeting email context rendering

1. Open a meeting detail page for a meeting with attendees who have recent email activity.
2. A "Recent Correspondence" (or equivalent) section appears showing email signals from those attendees — contextual summaries, not raw email rows.
3. The data comes from `FullMeetingPrep.recentEmailSignals` (already populated by the backend). This is a frontend rendering task.
4. If no email signals exist for the meeting's attendees, the section does not render (no empty state).
5. Clicking an email signal in this section navigates to the email page, not a dead link.

---

### I372 — Email-entity signal compounding

1. Receive an email with negative sentiment from a contact at Acme. Check the Acme account detail page. The email's sentiment signal has been emitted to the entity signal graph — visible in the signal timeline or affecting the entity's health indicators.
2. Receive a commitment email ("We'll send the contract by Friday"). The commitment is extracted AND a `commitment_received` signal is emitted for the related entity. Verify in `signal_events` table.
3. The email bridge (`signals/email_bridge.rs`) runs on EVERY enriched email, not just emails linked to upcoming meetings. Entity signals from emails apply to accounts, projects, and people — not just meetings. Verify: `SELECT DISTINCT entity_type FROM signal_events WHERE source LIKE '%email%'` returns at least `account` and `person`, not just `meeting`.
4. Signal propagation fires after email signals are emitted — if an email signal affects a person, it propagates to their linked accounts per existing propagation rules. Verify: after an email signal is emitted for a person, check `signal_events` for a corresponding propagated signal on their linked account.

---

### I373 — Email sync status indicator

1. Open the email page. A status indicator shows: last successful fetch time (e.g., "Updated 3 minutes ago"), and whether enrichment is complete or in progress.
2. If the last fetch failed (auth error, network error), the indicator shows a warning with the error context — not a silent failure.
3. On the daily briefing, the email section shows a subtle "as of X:XX AM" timestamp.
4. The `EmailSyncStatus` type's `usingLastKnownGood` field is surfaced: if the current data is from a stale fallback, the UI indicates this.

---

### I375 — Refresh button audit

1. Enumerate every refresh button (or icon trigger that re-fetches/re-enriches) across all pages: Daily Briefing, Week Forecast, Actions, Meeting Detail, Account Detail, Person Detail, Project Detail, Email page, Settings. List is confirmed complete before work begins.
2. Every refresh button is visually consistent with its page's add/action buttons — same sizing, icon weight, disabled-state treatment, and hover behavior. No page has a refresh button that uses a different design language than other interactive controls on the same surface.
3. Each refresh action targets only the data currently rendered on its page. A refresh on the Meeting Detail page does not re-enrich sections that have been removed from the layout. Verify by checking the invoked command or handler against the current page component — no orphaned enrichment calls.
4. Refresh buttons that trigger background work (async enrichment, AI pipeline) show a loading state for the duration. Clicking again while loading has no effect (button is disabled or re-entrant clicks are ignored).
5. No refresh button silently does nothing — if the action cannot be taken (e.g., already in progress, no data to refresh), it either shows a toast explaining why or the button is visibly disabled with a tooltip.

---

### I374 — Email dismissal learning

1. Dismiss 5 emails from the same sender domain over multiple days.
2. On subsequent polls, emails from that domain are classified lower (medium → low) without manual intervention.
3. The learning reads from `email_dismissals` table — verify the query groups by `sender_domain` and `email_type` with a threshold count.
4. The learning is additive to mechanical classification, not a hard override — a high-urgency email from a "learned low" domain still gets classified high if urgency keywords match.
5. A user can reset learned preferences from Settings.

---

### I386 — Calendar lifecycle gaps

Three gaps exist in how the calendar poller and timeline handle meeting lifecycle changes:

**Gap 1: Cancellation detection only covers today.** `detect_cancelled_meetings()` runs after each poll but only compares today's DB meetings against today's poll results. If a meeting scheduled for tomorrow or next week is cancelled in Google Calendar, it persists on the timeline indefinitely until the day arrives and the poller catches it.

**Gap 2: The poller only fetches today.** Future meetings only enter `meetings_history` when the user visits the Weekly Forecast page (live-fetch in `get_meeting_timeline`) or when `prepare_week` runs. A meeting added to the calendar for next Wednesday won't appear in the app between page visits.

**Gap 3: No rescheduling detection for future meetings.** `get_meeting_timeline` skips events whose `calendar_event_id` already exists in the DB. If a future meeting's time or title changes in Google Calendar, the old data persists. Only the calendar poller's `ensure_meeting_in_history()` detects changes — and it only polls today.

**Acceptance criteria:**

1. The calendar poller fetches **today through +7 days** on each cycle (not just today). New meetings added to the calendar for the coming week appear in the timeline within one poll interval (default 5 min) — without requiring a page visit.
2. `detect_cancelled_meetings()` runs against the **full ±7 day range**, not just today. Cancel a meeting scheduled for next Tuesday in Google Calendar. Within one poll cycle, the meeting disappears from the Weekly Forecast timeline (archived state).
3. Reschedule a future meeting in Google Calendar (change its time by 1 hour). Within one poll cycle, the timeline shows the **updated time**, not the stale original. Verify `meetings_history.start_time` and `end_time` match the Google Calendar values.
4. Rename a future meeting in Google Calendar. Within one poll cycle, the timeline shows the **updated title**. Verify `meetings_history.title` matches the new Google Calendar title.
5. The expanded poll range does not cause duplicate meetings. Verify: `SELECT id, COUNT(*) FROM meetings_history GROUP BY calendar_event_id HAVING COUNT(*) > 1` returns 0 rows.
6. Meeting prep regeneration fires when a meeting's entity links change due to reclassification after a title change. If "Team Sync" is renamed to "Acme QBR", the meeting should be reclassified and re-linked to the Acme account, and its prep should regenerate.

---

## Issue Dependencies

```
I365 (inbox fetch)
  └── I366 (reconciliation) — needs inbox-anchored fetch to compare sets
  └── I370 (thread refresh) — needs inbox fetch to check sent mail

I367 (mandatory enrichment)
  └── I369 (contextual synthesis) — needs enrichment pipeline as foundation
  └── I372 (signal compounding) — needs enrichment to extract signals first

I368 (persist to DB)
  └── I366 (reconciliation) — needs DB emails table to mark vanished
  └── I369 (synthesis) — needs DB for entity context queries
  └── I373 (sync status) — needs DB for enrichment state tracking

I371 (meeting email rendering) — independent, frontend only
I374 (dismissal learning) — independent, reads existing table
I375 (refresh button audit) — independent, UX/code review pass
I386 (calendar lifecycle) — independent, backend calendar poller changes
```

**Recommended build order:**
1. I368 (DB schema + migration) — foundational
2. I365 (inbox fetch) — changes the data source
3. I366 (reconciliation) — builds on inbox fetch + DB
4. I367 (mandatory enrichment) — enrichment pipeline
5. I369 (contextual synthesis) — the intelligence layer
6. I372 (signal compounding) — signals flow
7. I370 (thread refresh) — thread accuracy
8. I371 (meeting email context) — frontend wiring
9. I373 (sync status) — visibility
10. I374 (dismissal learning) — refinement

---

## Ship criteria

All acceptance criteria above are met across all 11 issues. No P0 or P1 bugs open. The email page shows contextually synthesized intelligence for every email — not raw sender+subject rows. An email from a known contact at a known account produces a summary that references the entity's current state and upcoming meetings. Emails archived in Gmail do not appear in DailyOS. "Replies Needed" accurately reflects threads awaiting user response. The meeting detail page shows email context from attendees. Email signals compound with entity intelligence.

### End-to-end smoke test (mandatory before tagging)

1. Clean app restart (`pnpm dev`). Gmail has ≥5 emails in inbox, at least 2 from known contacts at known accounts.
2. Wait for email poller to complete one cycle (≤2 min for fetch, ≤5 min for enrichment).
3. Open email page. Every email has a contextual summary — not raw sender+subject. At least 2 emails reference their related entity by name.
4. Archive 2 emails in Gmail. Wait one poll cycle. Confirm they disappear from the email page.
5. Open a meeting detail page for a meeting whose attendees have email activity. A "Recent Correspondence" section appears with contextual summaries.
6. Open an account detail page. Email signals from that account's contacts appear in the timeline — across multiple days if applicable.
7. Reply to a thread shown in "Replies Needed" via Gmail. Wait one poll cycle. The thread is gone from "Replies Needed."

The litmus test: open DailyOS in the morning. Without opening Gmail, understand what's happening in your email that affects your work today. Not "you have 12 emails" — "Jack confirmed the Acme EBR agenda, the Medico expansion thread has no new information, and Legal is waiting for your response on the SOW from Tuesday."
