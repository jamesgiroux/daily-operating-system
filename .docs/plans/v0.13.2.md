# v0.13.2 Version Brief

**Thesis:** Know what you built before you build the next layer. ADR-0086 defines the intended architecture: signals drive entity intelligence, entity intelligence drives meeting prep, meeting prep is mechanical. But the codebase grew across 13 versions and 350+ issues, and large portions have never been audited against actual design intent. `commands.rs` is 11,500 lines. `db/mod.rs` is 9,700 lines. Signal rules may be listening for events that are never emitted. `intelligence.json` fields may be produced but never consumed. The vector DB is generating embeddings in the background — but for what? This version answers those questions, fixes what doesn't match ADR-0086, and does the structural refactoring that the answers require. No new user-visible features. The deliverable is a codebase we can reason about.

**Status:** Planning.

---

## Scope

### In

| ID | Title | Area |
|----|-------|------|
| I376 | AI enrichment site audit — map every PTY/AI call site, verify ADR-0086 compliance | Architecture |
| I377 | Signal system completeness — emitter/propagation/consumer map, remove dead rules | Signals |
| I378 | Intelligence schema alignment — intelligence.json ↔ entity_intel ↔ frontend types | Architecture |
| I379 | Vector DB audit — map embedding writes vs. queries, disable orphaned paths | Architecture |
| I380 | commands.rs service extraction Phase 1 — complete services/ per SERVICE-CONTRACTS.md | Refactor |
| I381 | db/mod.rs domain migration — move queries into domain modules per SERVICE-CONTRACTS.md | Refactor |

### Explicitly out

- New user-visible features of any kind
- AppState decomposition (SERVICE-CONTRACTS.md Phase 3 state work — too risky adjacent to active features; v0.14.0 candidate)
- Frontend architecture changes (declared invariant in SERVICE-CONTRACTS.md)
- Workflow pipeline changes (Prepare → Deliver → Enrich is well-designed; keep as-is)
- New integrations
- Schema migrations (unless required to remove dead fields found in I378)

---

## Acceptance Criteria

Each criterion must be verified with real data in the running app. Compilation is not acceptance. A criterion is met when the described behavior or structural property is observable in the actual codebase or running app after a full `pnpm dev` restart.

---

### I376 — AI enrichment site audit

1. A written inventory exists at `.docs/research/i376-enrichment-audit.md` listing every `PtyManager` / Claude Code process invocation in the backend — file, line, function name, what it produces, where the output goes.
2. Every call site is classified: "follows ADR-0086 (entity-level, routes through intel_queue)" or "pre-ADR-0086 (meeting-level, inline, or orphaned)."
3. Any pre-ADR-0086 call sites found are either (a) removed, (b) redirected to route through intel_queue, or (c) documented as a deliberate ADR-0086 exception with a one-sentence rationale.
4. After remediation, `grep -rn "PtyManager::new\|PtyManager::for_tier" src-tauri/src/` returns a list — every entry has a corresponding entry in the inventory. The inventory and the grep output agree.
5. No command handler in `commands.rs` makes a direct PTY call for entity intelligence outside of `intel_queue`. The intel_queue is the sole path for entity-level AI enrichment.
6. Entity relinks (changing which account/project/person is linked to a meeting) trigger immediate prep re-assembly via `MeetingPrepQueue` — **no AI call, no reload required.** Verify: relink a meeting from one account to another in the running app. The meeting card on the daily briefing updates within 2 seconds to reflect the new entity's intelligence, without any user-initiated refresh. If the new entity has no `intelligence.json` yet, the card shows a "sparse" quality state and updates again automatically once background enrichment completes.

---

### I377 — Signal system completeness

1. A written map exists at `.docs/research/i377-signal-map.md` covering: every `bus.emit()` call site (signal type, entity type, source file), every propagation rule in `rules.rs` (what it listens for, what it derives), and every downstream consumer (callouts, cadence, invalidation, email bridge, post-meeting).
2. Every propagation rule has at least one confirmed emitter in the map. Rules listening for signal types with no emitter are either (a) given an emitter or (b) removed as dead code.
3. **User field edits emit signals.** Every command handler that writes a user correction to the DB (field updates on accounts, people, projects, stakeholder edits, intelligence field overrides) also calls `bus.emit()` so the change enters the signal chain. Verify by auditing each edit command handler in `commands.rs` against the signal map — any handler that writes to the DB but does not emit a signal is either (a) given an emitter or (b) documented as intentionally signal-free with a rationale. The test: edit a field on a known account in the running app; within one intel_queue cycle, `intelligence.json` for that account reflects the edit without any manual refresh.
4. `post_meeting.rs` fires reliably after a meeting ends. Verify with real data: after a completed meeting, `SELECT * FROM signal_events WHERE source LIKE '%post_meeting%' ORDER BY created_at DESC LIMIT 5` returns rows with timestamps matching the meeting end time.
5. `email_bridge.rs` fires on every enriched email, not only emails linked to upcoming meetings. Verify: `SELECT DISTINCT entity_type FROM signal_events WHERE source LIKE '%email%'` returns at least `account` and `person` — not just `meeting`.
6. Person → account signal propagation fires correctly. After an email signal is emitted for a person, `signal_events` contains a derived signal for that person's linked account within one propagation cycle. Verify with a known person-account pair.

---

### I378 — Intelligence schema alignment

1. A field-level comparison exists at `.docs/research/i378-schema-alignment.md` between: the `intelligence.json` schema produced by the AI prompt (for accounts, people, and projects), the `entity_intel` table columns in the DB, and the TypeScript types/hooks that consume them on the frontend. Every field is classified as "live" (produced AND consumed), "write-only" (produced, never read by frontend), or "dead" (in schema but never written or always null in real data).
2. Write-only fields are either (a) wired to a frontend consumer that surfaces them, or (b) removed from the AI prompt, schema, and DB column.
3. Dead fields are removed from prompt, schema, and DB (via migration if needed, or just schema/prompt change if the column is nullable and always null).
4. `entity_intel` table structure and `intelligence.json` schema are structurally consistent — no field exists in one but not the other without a documented reason in the alignment doc.
5. For any account, person, or project with real intelligence data: `SELECT * FROM entity_intel WHERE entity_id = '<id>'` and the corresponding `intelligence.json` on disk contain the same data at the same fields. No field is populated in one but null in the other without explanation.

---

### I379 — Vector DB audit

1. A written inventory exists at `.docs/research/i379-embeddings-audit.md` listing: every write to `content_embeddings` (what is embedded, what trigger, what collection/label), and every query that reads from `content_embeddings` (function name, what the results feed into, whether it's on a live user-facing path or dead code).
2. Every embedding write path is mapped to at least one downstream consumer. Embedding paths with no downstream consumer are identified as orphaned.
3. Orphaned embedding paths are either (a) wired to a consumer that meaningfully uses them, or (b) the background generation for that path is disabled. No embedding generation runs in the background unless it serves a live query.
4. The embedding processor (background task #9, nomic-embed-text-v1.5, ~137MB) is confirmed useful. If all embedding paths are orphaned after step 3, the processor is disabled until a consumer is built and this is documented.
5. If any semantic search is live (actively queried in a user-facing path): test it with at least 3 real queries using real indexed content and confirm results are semantically relevant — not just that the query function executes without error.

---

### I380 — commands.rs service extraction Phase 1

Following SERVICE-CONTRACTS.md Phase 1 exactly. One service at a time, verified before moving to the next.

1. `services/actions.rs` is complete per the ActionService contract in SERVICE-CONTRACTS.md. All action business logic moved from `commands.rs`. The action handlers in `commands.rs` are: parse args → call service → serialize response. No business logic remains in the handler. `cargo test` passes after each extraction.
2. Same for `services/accounts.rs` — AccountService contract fulfilled.
3. Same for `services/people.rs` — PersonService contract fulfilled.
4. Same for `services/meetings.rs` — MeetingService contract fulfilled.
5. `commands.rs` line count is measurably reduced. Measure before: `wc -l src-tauri/src/commands.rs`. Target after Phase 1: ≤9,000 lines.
6. `cargo clippy --manifest-path src-tauri/Cargo.toml --workspace --all-features --lib --bins -- -D warnings` passes clean.
7. The IPC surface is unchanged. No commands are renamed, removed, or have their argument shapes changed. The frontend does not need any changes. Verify: `git diff src/` shows no frontend changes.

---

### I381 — db/mod.rs domain migration

Following SERVICE-CONTRACTS.md Phase 3 (DB module split) exactly.

1. `db/actions.rs` owns all action queries. `db/mod.rs` contains no action-specific SQL (`grep "actions\|DbAction" src-tauri/src/db/mod.rs` returns only re-exports and column constants, not SQL strings).
2. `db/accounts.rs` owns all account queries. Same test.
3. `db/meetings.rs` owns meeting, attendee, and entity link queries. Same test.
4. `db/people.rs` owns all people CRUD and merge queries. Same test.
5. `db/mod.rs` retains only: `ActionDb` struct definition + `open()` + `conn_ref()`, `with_transaction()`, shared column `const` lists, and re-exports. Measure after: `wc -l src-tauri/src/db/mod.rs`. Target: ≤600 lines (down from ~9,700).
6. `cargo test` passes. `cargo clippy -- -D warnings` passes. No behavior changes — this is purely structural.

---

## Design Principle: Refresh as Last Resort

This version must establish — and verify — the following behavioral contract:

**No user-visible change to entity data should require a manual refresh or page reload to be reflected in the UI.**

The three change types and their expected latency:

| Change type | Example | AI required? | Expected latency | Mechanism |
|-------------|---------|-------------|-----------------|-----------|
| Entity pointer | Relink meeting Acme → Medico | No | <2 seconds | MeetingPrepQueue re-assembles from Medico's existing intelligence.json |
| User content edit | Correct a stakeholder, update strategic context | Yes (entity re-enrichment) | Seconds to minutes | Edit → signal → intel_queue → intelligence.json → prep invalidated → prep re-assembled → Tauri event → component updates |
| External signal | Transcript processed, email enriched | Yes (entity re-enrichment) | Minutes | Same chain as above, triggered by background poller |

**Folio bar refresh buttons are escape hatches, not the expected path.** They exist for:
- Automation failure (signal chain broke, pipeline got stuck — see: Cox Auto this morning)
- User-initiated force re-enrich NOW (wants immediate refresh with latest context before a meeting)

If a user has to click "Refresh" after editing a field to see their change reflected, that is a bug in the signal chain, not expected behavior. The acceptance criteria in I377 criterion 3 is the behavioral proof that this principle holds.

---

## Issue Dependencies

```
I376 (enrichment audit)
  └── informs I380 (service extraction) — audit may surface enrichment paths
       inside command handlers that need to move to services

I377 (signal map)
  └── no code dependencies, but findings may generate new issues

I378 (schema alignment)
  └── may require a DB migration (trivially small — just drop dead columns)
  └── informs I376 — audit may find AI prompts producing dead fields

I379 (vector audit)
  └── no code dependencies; may result in disabling background task #9

I380 (service extraction)
  └── addBlockedBy: I376 — don't extract before audit confirms no orphaned AI
       calls hiding in command handlers

I381 (db migration)
  └── independent — purely structural, no logic changes
```

**Recommended build order:**
1. I378 (schema alignment) — fast investigative, produces the field map
2. I376 (enrichment audit) — investigative, produces the call site inventory
3. I377 (signal map) — investigative, produces the signal map
4. I379 (vector audit) — investigative, may disable background task
5. I381 (db migration) — purely mechanical, low risk, no logic changes
6. I380 (service extraction) — largest structural change, do last with full audit context

---

## Ship criteria

All acceptance criteria above are met across all 6 issues. The audit documents exist in `.docs/research/`. `commands.rs` is ≤9,000 lines. `db/mod.rs` is ≤600 lines. Every AI enrichment call site follows ADR-0086. Every signal propagation rule has a confirmed emitter. Every `intelligence.json` field is live (produced and consumed) or removed. No orphaned embedding generation runs. `cargo test` passes. `cargo clippy -- -D warnings` passes. The IPC surface is unchanged.

### End-to-end smoke test (mandatory before tagging)

1. Clean app restart (`pnpm dev`). Open any account detail page — intelligence loads normally.
2. Open any meeting detail page — prep loads normally.
3. Open the signal debug view (or query `signal_events` directly) — signals are flowing after a calendar poll cycle.
4. Check logs — no PTY process invocations during normal app operation (only when the intel_queue triggers enrichment).
5. `wc -l src-tauri/src/commands.rs` returns ≤9,000. `wc -l src-tauri/src/db/mod.rs` returns ≤600.
6. No regressions on any surface visible in the running app. This version changes nothing the user sees.
